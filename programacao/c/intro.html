<!DOCTYPE html>
<html lang="pt-BR" manifest="/clebermatheus.appcache">
	<head>
		<!-- Cleber Matheus WebSite v0.9.8.5 -->
		<meta charset="UTF-8"/>
		<title>Introdução a Linguagem C</title>
		<link rel="stylesheet" href="/index.css"/>
		<meta name="generator" content="Notepad++ v6.7.2"/>
		<meta name="author" content="Cleber Matheus"/>
		<link rel="shortcut icon" href="favicon.png"/>
		<meta name="description" content="Introdução a Linguagem C"/>
		<meta name="reply-to" content="clebermatheus@outlook.com"/>
		<link rel="stylesheet" href="/mobile.css" media="screen and (max-width: 700px)"/>
		<meta name="keywords" content="Introdução ao C, Introduction to C, Introdução a Linguagem C"/>
		<link rel="alternate" type="application/atom+xml" href="/rss.xml" title="Cleber Matheus Website FeedRSS"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
	</head>
	<body onload="cache()" contextmenu="menu1">
		<header>
			<h1>Introdução a Linguagem C</h1>
			<a href="javascript:optMenu()" id="optMenu"><img id="Mimg" src="/menu@2x.png"/></a>
			<a href="javascript:subMenu()" id="opt2Menu" onclick="SMenu()">&#9660;</a>
		</header>
		<section id="conteudo">
			<div id="Ads">
				<div id="longAds">
					<script type="text/javascript">
						bb_bid = "1677784";
						bb_lang = "pt-BR";
						bb_name = "custom";
						bb_limit = "8";
						bb_format = "bbb";
					</script>
					<script type="text/javascript" src="http://static.boo-box.com/javascripts/embed.js"></script>
				</div>
			</div>
			<article id="introC">
				<p>C é uma linguagem de programação compilada de propósito geral,  estruturada, imperativa, procedural, padronizada pela ISO, criada em 1972, por Dennis Ritchie, no AT&T Bell Labs, para desenvolver o sistema operacional Unix (que foi originalmente escrito em Assembly). </p>
				<p>C é uma das linguagens de programação mais populares e existem poucas arquiteturas para as quais não existem compiladores para C. C tem influenciado muitas outras linguagens de programação, mais notavelmente C++, que originalmente começou como uma extensão para C.</p>
				<h2>História</h2>
				<p>O desenvolvimento inicial de C ocorreu no AT&T Bell Labs entre 1969 e 1973. De acordo com Ritchie, o período mais criativo ocorreu em 1972. A linguagem foi chamada "C", porque suas características foram obtidas a partir de uma linguagem anteriormente chamado de "B", que de acordo com a Ken Thompson era versão reduzida da linguagem de programação BCPL.</p>
				<p>A versão original PDP-11 do sistema Unix foi desenvolvido em assembly. Em 1973, com a adição dos tipos <code>struct</code>, a linguagem C tornou-se poderosa o suficiente para que a maior parte do <i>kernel</i> do Unix fosse reescrito em C. Este foi um dos primeiros núcleos de sistemas operacionais implementadas em uma linguagem diferente da linguagem Assembly. Em 1977, foram feitas novas mudanças por Ritchie e Stephen C. Johnson para facilitar a portabilidade do sistema operacional Unix. O <i>Portable C Compiler' de Johnson serviu de base para várias implementações de C em novas plataformas</i>.</p>
				<h3>C K&amp;R</h3>
				<p>A linguagem C não teve sucesso imediato após sua criação e seu uso ficou restrito a alguns laboratórios mas em 1978 Brian Kerningham e Dennis Rithcie lançam o livro <i>The C Programming Language</i>. Que serviu de tutorial e mudou a história da programação em C, de fato essa primeira versão da linguagem é conhecida como "C Kernigham e Ritchie" ou apenas "C K&amp;R".</p>
				<p>Esse livro, conhecido pelos programadores de C como "K&amp;R", serviu durante muitos anos como uma especificação informal da linguagem. A versão da linguagem C que ele descreve é usualmente referida como "<b>K&amp;R C</b>". A segunda edição do livro cobriu o padrão posterior, o ANSI C. K&amp;R C introduziu as seguintes características na linguagem:</p>
				<ul style="list-style-type: square;">
					<li>Biblioteca padrão de E/S</li>
					<li>Tipos de dados <code>struct</code></li>
					<li>Tipos de dados <code>long int</code></li>
					<li>Tipos de dados <code>unsigned int</code></li>
					<li>O operador =+ foi alterado para +=, e =- para -= (o analisador léxico do compilador fazia confusão entre i =+ 10 e i = +10. O mesmo acontecia com =-)</li>
				</ul>
				<p>K&amp;R C é frequentemente considerado a parte mais básica da linguagem, cujo suporte deve ser assegurado por um compilador C. Durante muitos anos, mesmo após a introdução do padrão ANSI C, K&amp;R C foi considerado o "menor denominador comum", em que programadores de C se apoiavam quando uma portabilidade máxima era desejada, já que nem todos os compiladores eram actualizados o bastante para suportar o padrão ANSI C.</p>
				<p>Nos anos que se seguiram à publicação do K&amp;R C, algumas características "não-oficiais" foram adicionadas à linguagem, suportadas por compiladores da AT&amp;T e de outros vendedores. Estas incluíam:</p>
				<ul style="list-style-type: square;">
					<li>Funções <code>void</code> e tipos de dados <code>void *</code></li>
					<li>Funções que retornam tipos <code>struct</code> ou <code>union</code></li>
					<li>Campos de nome <code>struct</code> num espaço de nome separado para cada tipo <code>struct</code></li>
					<li>Atribuição a tipos de dados <code>struct</code></li>
					<li>Qualificadores <code>const</code> para criar um objecto só de leitura</li>
					<li>Biblioteca padrão, que incorpora grande parte da funcionalidade implementada por vários vendedores</li>
					<li>Enumerações</li>
					<li>Cálculos de ponto-flutuante em precisão simples (no K&amp;R C, os cálculos intermediários eram feitos sempre em <code>double</code>, porque era mais eficiente na máquina onde a primeira implementação do C foi feita)</li>
				</ul>
				<h3>ANSI C e ISO C</h3>
				<p>Durante os finais da década de 1970, a linguagem C começou a substituir a linguagem BASIC como a linguagem de programação de microcomputadores mais usada. Durante a década de 1980, foi adaptada para uso no PC IBM, e a sua popularidade começou a aumentar significativamente. Ao mesmo tempo, Bjarne Stroustrup, juntamente com outros nos laboratórios Bell, começou a trabalhar num projecto onde se adicionavam construções de linguagens de programação orientada por objetos à linguagem C. A linguagem que eles produziram, chamada C++, é nos dias de hoje a linguagem de programação de aplicações mais comum no sistema operativo Windows da companhia Microsoft; C permanece mais popular no mundo Unix.</p>
				<p>Em 1983, o instituto norte-americano de padrões (ANSI) formou um comité, X3J11, para estabelecer uma especificação do padrão da linguagem C. Após um processo longo e árduo, o padrão foi completo em 1989 e ratificado como ANSI X3.159-1989 "Programming Language C". Esta versão da linguagem é frequentemente referida como ANSI C. Em 1990, o padrão ANSI C, após sofrer umas modificações menores, foi adotado pela Organização Internacional para Padronização (ISO) como <b>ISO/IEC 9899:1990</b>, também conhecido como C89 ou C90. Um dos objetivos do processo de padronização ANSI C foi o de produzir um sobre conjunto do K&amp;R C, incorporando muitas das características não-oficiais subsequentemente introduzidas. Entretanto, muitos programas tinham sido escritos e que não compilavam em certas plataformas, ou com um certo compilador, devido ao uso de bibliotecas de funções não-padrão e ao fato de alguns compiladores não aderirem ao ANSI C.</p>
				<h3>C99</h3>
				<p>Após o processo da padronização ANSI, as especificações da linguagem C permaneceram relativamente estáticas por algum tempo, enquanto a linguagem C++ continuou a evoluir. (em 1995, a <i>Normative Amendment 1</i> criou uma versão nova da linguagem C mas esta versão raramente é tida em conta.) Contudo, o padrão foi submetido a uma revisão nos finais da década de 1990, levando à publicação da norma <b>ISO 9899:1999</b> em 1999. Este padrão é geralmente referido como "C99". O padrão foi adoptado como um padrão ANSI em março de 2000. As novas características do C99 incluem:</p>
				<ul style="list-style-type: square;">
					<li>Funções em linha</li>
					<li>Remoção de restrições sobre a localização da declaração de variáveis (como em C++)</li>
					<li>Adição de vários tipos de dados novos, incluindo o <code>long long int</code> (para minimizar problemas na transição de 32-bits para 64-bits), um tipo de dado boolean explicito (chamado <i>_Bool</i>) e um tipo <code>complex</code> que representa números complexos</li>
					<li>Vetores de dados de comprimento variável (o vetor pode ter um tamanho diferente a cada execução de uma função, mas não cresce depois de criado)</li>
					<li>Suporte oficial para comentários de uma linha iniciados por //, emprestados da linguagem C++</li>
					<li>Várias funções de biblioteca novas, tais como <code>snprintf()</code></li>
					<li>Vários ficheiros-cabeçalho novos, tais como <code>stdint.h</code></li>
				</ul>
				<p>O interesse em suportar as características novas de C99 parece depender muito das entidades. Apesar do GCC e vários outros compiladores suportarem grande parte das novas características do C99, os compiladores mantidos pela Microsoft e pela Borland suportam pouquíssimos recursos do C99, e estas duas companhias não parecem estar muito interessadas em adicionar tais funcionalidades, ignorando por completo as normas internacionais. A Microsoft parece preferir dar mais ênfase ao C++.</p>
				<h3>C11</h3>
				<p>Em 2007, se iniciou o trabalho em antecipação de outra revisão do padrão de C, informalmente chamada de <b>C11</b> ou <b>C1X</b>. O comitê dos padrões de C adotou regras para limitar a inserção de novos recursos que não tenham ainda sido testados por implementações existentes.</p>
				<p>Em dezembro de 2011 foi publicada a versão estável da especificação, como <b>ISO/IEC 9899:2011</b>.</p>
				<h2>Visão Geral</h2>
				<p>C é uma linguagem imperativa e procedural, para implementação de sistemas. Seus pontos de design foram para ele ser compilado, fornecendo acesso de baixo nível à memória e baixos requerimentos do hardware. Também foi desenvolvido para ser uma linguagem de alto nível, para maior reaproveitamento do código. C foi útil para muitas aplicações que foram codificadas originalmente em Assembly.</p>
				<p>Essa propriedade não foi acidental; a linguagem C foi criada com o objetivo principal em mente: facilitar a criação de programas extensos com menos erros, recorrendo ao paradigma da programação procedural, mas sobrecarregando menos o autor do compilador, cujo trabalho complica-se ao ter de realizar as características complexas da linguagem. Para este fim, a linguagem C possui as seguintes características:</p>
				<ul style="list-style-type: square;">
					<li>Uma linguagem extremamente simples, com funcionalidades não-essenciais, tais como funções matemáticas ou manuseamento de ficheiros (arquivos), fornecida por um conjunto de bibliotecas de rotinas padronizada</li>
					<li>A focalização no paradigma de programação procedural</li>
					<li>Um sistema de tipos simples que evita várias operações que não fazem sentido</li>
					<li>Uso de uma linguagem de pré-processamento, o <b>pré-processador de C</b>, para tarefas tais como a definição de macros e a inclusão de múltiplos ficheiros de código fonte</li>
					<li>Ponteiros dão maior flexibilidade à linguagem</li>
					<li>Acesso de baixo-nível, através de inclusões de código Assembly no meio do programa C</li>
					<li>Parâmetros que são sempre passados por valor para as funções e nunca por referência (É possível simular a passagem por referência com o uso de ponteiros)</li>
					<li>Definição do alcance lexical de variáveis</li>
					<li>Estruturas de variáveis, (structs), que permitem que dados relacionados sejam combinados e manipulados como um todo</li>
				</ul>
				<p>Algumas características úteis, que faltam em C, podem ser encontradas em outras linguagens, que incluem:</p>
				<ul style="list-style-type: square;">
					<li>Segurança de tipo</li>
					<li>Coletor de lixo (mais comum em linguagens interpretadas)</li>
					<li>Vetores que crescem automaticamente</li>
					<li>Classes ou objetos com comportamento</li>
					<li>Clausuras</li>
					<li>funções aninhadas</li>
					<li>Sobrecarga de operadores</li>
					<li>Meta-programação</li>
					<li>Apoio nativo de <i>multithreading</i> e comunicação por rede</li>
				</ul>
				<p>Apesar da lista de características úteis que C possui não ser longa, isso não tem sido um impedimento à sua aceitação, pois isso permite que novos compiladores de C sejam escritos rapidamente para novas plataformas, e também permite que o programador permaneça sempre em controle do que o programa está a fazer. Isto é o que por várias vezes permite o código de C correr de uma forma mais eficiente que muitas outras linguagens. Tipicamente, só código de Assembly "afinado à mão" é que corre mais rapidamente, pois possui um controle completo da máquina, mas avanços na área de compiladores juntamente com uma nova complexidade nos processadores modernos permitiram que a diferença tenha sido rapidamente eliminada. Uma consequência da aceitação geral da linguagem C é que frequentemente os compiladores, bibliotecas e até intérpretes de outras linguagens de nível maior sejam eles próprios implementados em C.</p>
				<p>C tem como ponto forte, a sua eficiência, e é a linguagem de programação preferida para o desenvolvimento de sistemas e softwares de base, apesar de também ser usada para desenvolver programas de computador. É também muito usada no ensino de ciência da computação, mesmo não tendo sido projetada para estudantes e apresentando algumas dificuldades no seu uso. Outra característica importante de C, é sua proximidade do código de máquina, que permite que um projetista seja capaz de fazer algumas previsões de como o software irá se comportar, ao ser executado.</p>
				<p>C tem como ponto fraco, a falta de proteção que dá ao programador. Praticamente tudo que se expressa em um programa em C, pode ser executado, como por exemplo, pedir o vigésimo membro de um vetor com apenas dez membros. Os resultados são muitas vezes totalmente inesperados, e os erros, difíceis de encontrar.</p>
				<h3>Tipos de Dados</h3>
				<p>C tem um sistema de tipos semelhante ao de alguns descendentes da linguagem ALGOL, tais como Pascal. Possui tipos para números inteiros de vários tamanhos com e sem sinal, números de ponto flutuante, caracteres e estruturas (<code>structs</code>). C usa extensivamente ponteiros, um tipo muito simples de <b>referência</b> que guarda o endereço de memória da variável. O ponteiro pode ser <i>desreferenciado</i>, uma operação que busca o objecto que se encontra na morada da memória que o ponteiro possui, morada essa que pode ser manipulada através de aritmética de ponteiros. Durante o tempo de execução, o ponteiro é simplesmente uma morada de máquina tais como aquelas manipuladas em <i>Assembly</i>, mas em tempo de compilação possui um tipo complexo que indica o tipo do objecto para onde ele aponta, permitindo que se verifique o tipo de expressões, incluindo ponteiros. Os ponteiros são usados extensivamente em C. O tipo linha de texto de C é simplesmente um ponteiro para um vetor de caracteres e alocação dinâmica de memória, descrita abaixo, é efetuada através de ponteiros.</p>
				<p>Os ponteiros em C possuem um valor reservado especial, <code>NULL</code>, que indica que não estão a apontar para uma morada. O uso desse valor como morada é muito útil na construção de várias estruturas de dados, mas causa comportamento não-definido (possivelmente uma falha de sistema) ao ser desreferenciado. Um ponteiro que possui o valor <code>NULL</code> é chamado <i>ponteiro nulo</i>. Os ponteiros são declarados (e desreferenciados) com um * (asterisco), portanto o tipo <code><i>int*</i></code> denota um ponteiro para número(s) inteiro(s). A linguagem C também fornece um tipo especial de ponteiros, o <code><i>void*</i></code>, que se traduz num ponteiro que aponta para um objecto de tipo desconhecido.</p>
				<p>A linguagem C também tem apoio a nível de linguagem para vetores estáticas (de dimensão fixa) de tipos. As disposições de tipos podem parecer ter mais que uma dimensão apesar de serem tecnicamente disposições de disposições de tipos. Em memória, tais estruturas são posicionadas com as linhas uma depois da outra (a alternativa seria armazenar os dados em colunas, usado em outras linguagens). O acesso a disposições de tipos é feito através de ponteiros e aritmética de ponteiros; o nome da disposição é tratado como se fosse um ponteiro que aponta para o início da disposição. Em certas aplicações não é razoável usarem-se disposições de tipos de dimensão fixa e por isso a alocação dinâmica de memória pode ser usada para criar disposições de tipos de dimensão variável.</p>
				<p>Como a linguagem C é regularmente usada em programação de baixo-nível de sistemas, há casos em que é necessário tratar um número inteiro como sendo um ponteiro, um número de ponto flutuante como sendo um número inteiro ou um tipo de ponteiro como sendo outro. Para estes casos, a linguagem C fornece a capacidade de "moldagem" (também denominado "conversão de tipo" ou casting), uma operação que, caso seja possível, força a conversão de um objecto de um tipo para outro. Apesar de ser por vezes necessário, o uso de conversões de tipo sacrifica alguma segurança oferecida pelo sistema de tipos.</p>
				<h4>int</h4>
				<p>O tipo de dado <b>int</b> (inteiro) serve para armazenar valores numéricos inteiros. Existem vários tipos de inteiros, cada um de um tamanho diferente (dependendo do sistema operacional e/ou arquitetura do processador):</p>
				<ul style="list-style-type: square;">
					<li><code>int</code>, pode possuir 16 bits, 32 bits ou 64 bits</li>
					<li><code>short int</code>, deve possuir tamanho de no mínimo 16 bits e não pode ser maior que <code>int</code></li>
					<li><code>long int</code>, deve possuir tamanho mínimo de 32 bits</li>
					<li><code>long long int</code>, deve possuir tamanho mínimo de 64 bits</li>
				</ul>
				<p>Todos estes tipos de inteiros podem ainda ser declarados precedidos da cláusula <code>unsigned</code>, o que faz com que só suporte números positivos. Isto faz com que, com o mesmo tamanho, uma variável suporte mais números positivos do que um <code>signed</code> (todos os inteiros são signed por omissão).</p>
				<h4>char</h4>
				<p>O tipo <b>char</b> ocupa 1 byte, e serve para armazenar caracteres ou inteiros. Isso significa que o programa reserva um espaço de 8 bits na memória RAM ou em registradores do processador para armazenar um valor (<b>char</b> de tamanho maior que 8 bits é permitido pela linguagem, mas os casos são raros). Com vetores do tipo char é possível criar cadeias de caracteres (strings).</p>
				<h4>float</h4>
				<p>O tipo de dado <b>float</b> serve para armazenar números de ponto flutuante, ou seja, com casas decimais. O padrão mais utilizado nos últimos 10 anos é o IEEE 754-1985.</p>
				<h4>double</h4>
				<p>O tipo de dado <b>double</b> serve para armazenar números de ponto flutuante de dupla precisão, normalmente tem o dobro do tamanho do float e portanto o dobro da capacidade. O padrão mais adotado também é o IEEE 754-1985.</p>
				<h4>struct</h4>
				<p>Em C podem ser usadas estruturas (chamados de registos em outras linguagens de programação). As estruturas são grupos de variáveis organizadas arbitrariamente pelo programador. Uma estrutura pode criar um novo tipo de variável caso typedef seja usado em sua declaração.</p>
				<h2>Relações com C++</h2>
				<p>A linguagem de programação C++ foi originalmente derivada do C para suportar programação orientada a objetos. À medida que as linguagens C e C++ foram evoluindo independentemente, a divisão entre as duas veio a aumentar. O padrão C99 criou um número de características que entram em conflito. Hoje, as principais diferenças entre as duas linguagens são:</p>
				<ul style="list-style-type: square;">
					<li><code>inline</code> - em C++, funções em linha encontram-se no espaço global enquanto que em C encontram-se no espaço local. Por outras palavras, isso significa que, em C++, qualquer definição de qualquer função em linha (sem ser a respeito da sobrecarga de funções de C++) tem de estar em conformidade com a "regra de uma definição" da linguagem C++. Mas em C, a mesma função em linha pode ser definida de maneira diferente em diferentes arquivos (ou ficheiros)</li>
					<li>A palavra-chave <code>bool</code>, igual à usada em C++, em C99 necessita que se inclua o arquivo-cabeçalho <code>&lt;stdbool.h&gt;</code> (_Bool está sempre disponível). Padrões anteriores de C não definiam um tipo booleano e vários (e incompatíveis) métodos foram usados para simular um tipo booleano</li>
				</ul>
				<p>Algumas características originalmente desenvolvidas em C++ também apareceram em C. Entre elas encontram-se:</p>
				<ul style="list-style-type: square;">
					<li>protótipos de função (com declaração de tipos de parâmetros) e remoção do "int" implícito</li>
					<li>comentários de linha, indicados por //; comentários de linha terminam com um caractere de nova-linha</li>
					<li>a palavra-chave <code>inline</code></li>
					<li>tipagem mais forte</li>
				</ul>
				<h2>Exemplos</h2>
				<h3>Programa Olá Mundo</h3>
				<p>A seguinte aplicação foi publicada na primeira edição de C de K&amp;R, e tornou-se no programa de introdução padrão da maior parte dos livros sobre C. O programa envia o texto "Olá, Mundo!" para a saída padrão, que é normalmente o console, mas que também pode ser um ficheiro (ou arquivo), um outro dispositivo qualquer, ou até mesmo um <i>bit bucket</i>, dependendo de como a saída-padrão é mapeada na altura em que o programa é executado.</p>
				<pre>int main(){
	puts("Olá, Mundo!");
}</pre>
				<p>Apesar do programa acima correr corretamente, atualmente origina algumas mensagens de aviso quando compilado como C ANSI. Essas mensagens podem ser eliminadas efetuando umas pequenas alterações no programa original:</p>
				<pre>#include &lt;stdio.h> /* Pacotes com funções de entrada e saída */

int main(){
	puts("Olá, Mundo!");
	return 0;	/* Retorna 0, pois `main` retorna um `int` */
}
/* Nova linha após fechar a chave principal */</pre>
				<p>A primeira linha do programa é uma diretiva de pré-processamento <code>#include</code>, que causa com que o pré-processador substitua aquela linha pela totalidade do conteúdo do arquivo qual diretiva se refere. Neste caso o arquivo padrão <code>stdio.h</code> (que contém protótipos de funções para trabalho com entrada e saída) irá substituir a linha. Os caracteres &lt; e &gt; indicam que o arquivo stdio.h encontra-se no local em que, quando da configuração do compilador, se definiu como padrão para localização dos ficheiros de inclusão (<i>header files</i>, geralmente com a extensão <i>.h</i>).</p>
				<p>A linha (não-vazia) seguinte indica que uma função denominada <i>main</i> será definida. A função <i>main</i> tem um significado especial nos programas em C, pois é a função que é inicialmente executada (em inglês, <i>entry point</i>). Os caracteres { e } delimitam a extensão da função. O termo <code>int</code> define a função <i>main</i> como sendo uma função que retorna um número inteiro. O termo <code>void</code> indica que a função não aceita parâmetros. A função <i>main</i>, normalmente aceita parâmetros, que são passado pela linha de comando. Os compiladores e sistemas operacionais atuais reconhecem as seguintes declarações de main:</p>
				<pre>int main(void);
int main(int argc, char *argv[]);
int main(int argc, char **argv);</pre>
				<p>A linha seguinte "chama", ou executa uma função chamada <code>puts</code>; o arquivo incluído, <code>stdio.h</code>, contém a informação que descreve a forma como a função <code>puts</code> deve ser chamada. Nesta chamada, é passado à função <code>printf</code> um único argumento, a linha de texto constante "Olá, Mundo!". A função <code>puts</code> retorna um valor, um <code>int</code>, mas como não é usado, é descartado pelo compilador. O comando <code>return</code> retorna o valor 0 para o sistema, que é interpretado pelo mesmo como que a função main() foi executada e encerrada com sucesso (sem erros). Por fim, o caracter } indica o fim da função <code>main</code>. Note-se que texto rodeado por /* e */ (comentários de texto) é ignorado pelo compilador. Os compiladores que obedecem à norma C99 também aceitam como comentários as linhas de texto que são precedidos por //.</p>
				<h3>Matemática</h3>
				<p>O seguinte código realiza seis operações matemáticas, adição, subtração, multiplicação, divisão, exponenciação e radiciação, e em seguida envia os seus respectivos resultados para a saída padrão (normalmente o console).</p>
				<pre>#include &lt;math.h>  // necessária para pow() e sqrt()
#include &lt;stdio.h> // necessária para printf() e getchar()
 
int main(){
   int a = 2, b = 3;
 
   printf("%d + %d = %d\n", a, b, a + b);
   printf("%d - %d = %d\n", a, b, a - b);
   printf("%d x %d = %d\n", a, b, a * b);
   printf("%d / %d = %0.1f\n", a, b, (float) a / b); // resultado fracionário
   printf("%d elevado a %d = %0.1f\n", a, b, pow(a, b)); // pow(base, expoente)
   printf("raiz quadrada de %d = %0.1f\n", a, sqrt(a));
 
   getchar(); //O uso dessa função é necessária apenas nos sistemas Windows, para manter o terminal (Prompt de comando) aberto
   return 0;
}</pre>
				<h3>Estruturas de Dados</h3>
				<p>No exemplo seguinte, é criada uma estrutura composta por 3 elementos de tipos diferentes. Após ser declarada uma variável "x" do tipo struct "y", onde "y" é o nome da estrutura, para se acessar os elementos usa-se a seguinte sintaxe: <code>x.elemento</code>.</p>
				<pre>#include &lt;stdio.h>
 
struct Pessoa {
   char nome[64]; // vetor de 64 chars para o nome
   unsigned short int idade;
   char rg[13];
};
 
int main(){
   struct Pessoa exemplo = {"Fulano", 16, "00.000.000-00"}; // declaração da variável "exemplo"
 
   printf("Nome: %s\n", exemplo.nome);
   printf("Idade: %hu\n", exemplo.idade);
   printf("RG: %s\n", exemplo.rg);
 
   getchar(); // desnecessário, mas comumente utilizado em ambientes windows para "segurar" o terminal aberto
   return 0;
}</pre>
				<p>Ou, equivalente:</p>
				<pre>#include &lt;stdio.h>
 
typedef struct Pessoa {
   char nome[64]; // vetor de 64 chars para o nome
   unsigned short int idade;
   char rg[13];
} Pessoa;
 
int main(){
   Pessoa exemplo = {"Felipe", 16, "00.000.000-00"}; // declaração da variável "exemplo"
 
   printf("Nome: %s\n", exemplo.nome);
   printf("Idade: %hu\n", exemplo.idade);
   printf("RG: %s\n", exemplo.rg);
 
   getchar();
   return 0;
}</pre>
				<h2>Baixo-nível</h2>
				<p>O exemplo que se segue apresenta código C de baixo-nível, as funções read e write. Neste programa vamos ler de N para buf, blocos de bufsize neste caso 1024, para O. Quando n for igual a 0, é porque a leitura acabou, sai do ciclo while e libera a memória ocupada por buf.</p>
				<pre>#include &lt;unistd.h>
#define bufsize 1024;
 
int main(void){
  int N,n,O;
  char *buf;
 
  buf = (char*) malloc (bufsize);
 
  while(n=read(N, buf, bufsize))
        write(O, buf,n)
  free(buf);
 
  return 0;
}</pre>
				<footer>
					<p>Baseado no artigo: <a href="http://pt.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)">C (linguagem de programação) - Wikipédia, a enciclopédia livre</a></p>
					<time datetime="2014-01-07" pubdate="pubdate">Artigo publicado em 7 de Janeiro de 2014</time>
				</footer>
			</article>
			<div id="Ads">
				<div id="longAds">
					<script type="text/javascript">
						bb_bid = "1677784";
						bb_lang = "pt-BR";
						bb_name = "custom";
						bb_limit = "8";
						bb_format = "bbb";
					</script>
					<script type="text/javascript" src="http://static.boo-box.com/javascripts/embed.js"></script>
				</div>
			</div>
		</section>
		<section id="subMenu" onclick="SMenu()">
			<nav id="nav2">
				<ul id="NPr">
					<li><a href="/programacao/assembly/">Assembly</a></li>
					<li><a href="/programacao/c/">C</a></li>
					<li><a href="/programacao/cpp/">C++</a></li>
					<li><a href="/programacao/csharp/">C#</a></li>
					<li><a href="/programacao/java/">Java</a></li>
				</ul>
			</nav>
		</section>
		<section id="HoverMenu" onclick="HMenu()">
			<nav id="nav1">
				<ul id="MPr">
					<li><a href="/">Página Inicial</a></li>
					<li><a href="/app/">Aplicativos</a></li>
					<li><a href="/games/">Jogos</a></li>
					<li><a href="/projetos/">Meus Projetos</a></li>
					<li><a href="/opensource/">OpenSource</a></li>
					<li><a href="/programacao/">Programação</a></li>
					<li><a href="/sobre/">Sobre</a></li>
					<li><a href="/support/">Suporte</a></li>
					<li><a href="/videos/">Vídeos</a></li>
					<li><a href="/webdesign/">WebDesign</a></li>
					<li><a href="/rss.xml">Feed RSS</a></li>
				</ul>
			</nav>
			<section id="MenuTab">
				<section id="Tabs">
					<span id="Tab0" class="active" onclick="ChangeTab('Tab', 0)">Linguagens</span>
					<span id="Tab1" class="inactive" onclick="ChangeTab('Tab', 1)">Extras</span>
				</section>
				<section id="Content">
					<section id="ConTab0" class="active">
						<a href="/programacao/assembly/"><img src="/programacao/assembly/favicon.png" alt="Assembly"/><span>Assembly</span></a>
						<a href="/programacao/c/" style="left: 10px;"><img src="/programacao/c/favicon.png" alt="C"/><span>C</span></a>
						<a href="/programacao/cpp/" style="left: 20px;"><img src="/programacao/cpp/favicon.png" alt="C++"/><span>C++</span></a>
						<a href="/programacao/csharp/" style="left: 30px;"><img src="/programacao/csharp/favicon.png" alt="C#"/><span>C#</span></a>
						<a href="/programacao/java/" style="left: 40px;"><img src="/programacao/java/favicon.png" alt="Java"/><span>Java</span></a>
					</section>
					<section id="ConTab1" class="inactive">
						<div id="ads">
							<script type="text/javascript">
								bb_bid = "1677784";
								bb_lang = "pt-BR";
								bb_name = "custom";
								bb_limit = "4";
								bb_format = "bbk";
							</script>
							<script type="text/javascript" src="http://static.boo-box.com/javascripts/embed.js"></script>
						</div>
						<footer id="footer1">
							<p>Cleber Matheus Website - 2015</p>
							<time datetime="2015-01-07" pubdate="pubdate">7 de Janeiro de 2015</time>
							<button onclick="cache()">Atualizar!</button>
						</footer>
					</section>
				</section>
			</section>
		</section>
		<menu id="menu1" type="context">
			<menuitem id="sobre1" onclick="about()">Sobre...</menuitem>
			<menuitem id="asm1" onclick="assembly()">Assembly</menuitem>
			<menuitem id="c1" onclick="c()">C</menuitem>
			<menuitem id="cpp1" onclick="cpp()">C++</menuitem>
			<menuitem id="csharp1" onclick="csharp()">C#</menuitem>
			<menuitem id="java1" onclick="java()">Java</menuitem>
		</menu>
		<script type="text/javascript" async src="/index.js"></script>
	</body>
</html>
